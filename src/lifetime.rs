// 「ライフタイム」
// Rustの所有権システムの３つ目。

// 他の誰かの所有するリソースへの参照の貸付は複雑になることがある。
// 例えば以下の例を考える。
// 1. 私はある種のリソースへのハンドルを取得する
// 2. 私はあなたにリソースへの参照を貸し付ける
// 3. 私はリソースを使い終わり、それを解放することを決めるが、あなたはそれに対する参照をまだ持っている
// 4. あなたはリソースを使うことを決める
// この時点であなたの持つ参照は無効なリソースを指示している。
// リソースがメモリである時、これをダンクリングポインタと呼ぶ。

// これを修正するために、3. の後に4. が絶対に起こらないようにする必要がある。
// Rustの所有権システムはこれをライフタイムと呼ばれる概念を通じて行う。
// それは参照の有効なスコープを記述するものである。

// 引数として参照を受け取る関数について、参照のライフタイムを黙示または明示できる。
// 黙示的に
fn foo(x: &i32) {
}

// 明示的に
fn bar<'a>(x: &'a i32) {
}

// 'a は「ライフタイムa」と読む。参照は全てそれに関するライフタイムを持っているが、
// 一般的な場合にはコンパイラがそれらを省略しても良いように計らっている。

// 明示的なライフタイムに関して分解して考える。
// 関数は <> の間に「ジェネリックパラメータ」を持つことができ、ライフタイムはその一種。
fn bar<'a, 'b> (...)
// これは関数 bar が二つの参照引数を持ち、それぞれにライフタイムを宣言している。
// そして引数リストで、名付けたライフタイムを使う。
...(x: &'a i32)
// もし &mut 参照が欲しいのならば、次のようにする。
...(x: &'a mut i32)
// &mut i32 と &'a mut i32 は同じことを表す。それはライフタイムが黙示的が明示的かの違いだけ。

// 参照を含む struct を使う時も明示的なライフタイムを必要とする。
struct Foo<'a> {
  x: &'a i32,
}

fn main() {
  let y = &5; // これは let _y = 5; let y = &_y; と同じ
  let f = Foo { x: y };

  println!("{}", f.x);
}
// これはつまり Foo への参照よりも x への参照が先に切れないようにしているということ。

// 「impl ブロック」
// Foo に次のようなメソッドを実装する。
struct Foo<'a> {
  x: &'a i32,
}

impl<'a> Foo<'a> {
  fn x(&self) -> &'a i32 { self.x }
}

fn main() {
  let y = &5;
  let f = Foo { x: y };

  println!("x is: {}", f.x());
}
// 上記のように、Foo のライフタイムは impl 行で宣言する必要がある。

// もし複数の参照があれば、同じライフタイムを複数回使うこともできる。
fn x_or_y<'a>(x: &'a str, y: &'a str) -> &'a str { }
// これは x と y が同じスコープで有効であり、戻り値もそのスコープで有効であることを示す。


// ライフタイムについて考えるには、参照の有効なスコープを可視化すると良い
fn main() {
  let x;                   // -+ x がスコープに入る
                           //  |
  {                        //  |
    let y = &5;            // ---+ y がスコープに入る
    let f = Foo { x: y };  // ---+ f がスコープに入る
    x = &f.x;              //  | | ここでエラーが起きる
  }                        // ---+ f と y がスコープから出る
                           //  |
  println!("{}", x);       //  |
}                          // -+ x がスコープから出る
// ここでは f と y のスコープは x よりも小さいが、x = &f.x を実行する時、
// x をまさにスコープから外れた何かの参照にしてしまう。
// 名前のついたライフタイムはそれらのスコープに名前を与える方法である。


// 「static」と名付けられたライフタイムはプログラム全体に渡るライフタイムを持つことを示す。
let x: &'static str = "Hello, world.";
// 文字列リテラルは &'static str 型を持つ。
// 参照が常に有効であり、最終的なバイナリのデータセグメントに焼き付けられる。
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
// これはバイナリのデータセグメントに i32 を焼き付けることを意味する。


// ライフタイムの省略を行うこともできる
// Rustは強力なローカル型推論をサポートしている。しかし要素の構造を表すときは、
// 型が要素の構造だけでわかるように型推論が許されていない。
// しかし、ライフタイムの推論はサポートされている。
// それらは３つの明確なルールに従って行われる。

// 入力ライフタイム：関数の引数に関連するライフタイム
fn foo<'a>(bar: &'a str) { }
// 出力ライフタイム：関数の戻り値に関連するライフタイム
fn foo<'a>() -> &'a str { }

// ルール1. 関数の引数の中の省略された各ライフタイムは互いに異なるライフタイムパラメータになる
// ルール2. もし入力ライフタイムが１つだけならば、省略されたかどうかに関わらず、
//          そのライフタイムはその関数の戻り値の中の省略されたライフタイム全てに割り当てられる
// ルール3. もし入力ライフタイムが複数あるが、その１つが &self または &mut self であれば、
//          self のライフタイムは省略された出力ライフタイム全てに割り当てられる
// これらに該当しない時は、出力ライフタイムの省略はエラーとなる

// 以下にライフタイムの省略された形と展開された形の例を示す
fn print(s: &str);
fn print<'a>(s: &'a str);

fn debug(lvl: u32, s: &str);
fn debug<'a>(lvl: u32, s: &'a str);
// 上記の lvl がライフタイムを必要としない。なぜなら参照(または参照を含むもの)ではないから。

fn substr(s: &str, until: u32) -> &str;
fn substr<'a>(s: &'a str, until: u32) -> &'a str;

fn get_str() -> &str; // 不正。入力がない

fn frob(s: &str, t: &str) -> &str;
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // 出力ライフタイムが決まらない

fn get_mut(&mut self) -> &mut T;
fn get_mut<'a>(&'a mut self) -> &'a mut T;

fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command;
fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command;

fn new(buf: &mut [u8]) -> BufWriter;
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>;

