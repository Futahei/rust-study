fn main() {
  // 変数束縛
  // 値を名前に束縛する
  let x = 5;

  // 普通の言語にある変数と違うのは、
  // 左式がパターンでも構わないということ
  let (x, y) = (1, 2);
  
  // 型アノテーション
  // Rustは静的型付言語で、型推論も行うが明示的に書くこともできる
  // Rustには多くのプリミティブ型がある
  // 整数型は符号付きは「i」, 符合なしは「u」から始まる
  // サイズは8, 16, 32, 64ビットがある
  let x: i32 = 5;

  // デフォルトでは束縛はイミュータブル(変更不可)
  // つまり以下はコンパイルを通らない
  // let x = 5;
  // x = 10;
  // よって可変にしたいなら「mut」を使う
  let mut x = 5;
  x = 10;

  // 束縛の初期化は基本的に必須
  // つまり以下のような場合は警告が出る
  // let x: i32;
  // 特に、上記の変数を使用しようとするとエラーが出る

  // 変数束縛はブロック内でしか有効でない
  let x: 32 = 17;
  {
    let y: i32 = 3;
    println!("The value of x is {} and value of y is {}", x, y);
  }
  // 以下は動かない
  // println!("The value of x is {} and value of y is {}", x, y);

  // 変数束縛を覆い隠すことをシャドーイングという
  // 以下の例のように同名の変数名を上書きしていける
  let x; i32 = 8;
  {
    println!("{}", x); // "8"を印字する
    let x = 12;
    println!("{}", x); // "12"を印字する
  }
  println!("{}", x); // "8"を印字する
  let x = 42;
  println!("{}", x); // "42"を印字する
  // シャドーイングとミュータブルな変数束縛は似ているが全く別の概念
  // 例えばシャドーイングは同名の変数に違う型の値を束縛できる
  let mut x: i32 = 1;
  x = 7;
  let x = x; // xはイミュータブルになって7に束縛される

  let y = 4;
  let y = "I can also be found to text!"; // yは違う型になった

  // 関数
  fn foo() {
  }
  // 引数あり関数
  // 引数の型を必ず宣言しなければならない
  fn print_number_sum(x: i32, y: i32) {
    println!("number sum: {}", x + y);
  }
  // 返り値あり関数
  fn add_one(x: i32) -> i32 {
    x + 1
  }

  // Rustは式ベースの言語
  // 式は値を返し、文は返さない
  // 文には二種類ある
  // 「宣言文」
  let x = 5;
  // let x = (let y = 5); これはエラー
  // let x = (y = 6); これもエラー、xは()を持っているだけ
  // 「式文」
  // 式を文に変換する目的のもの
  fn hoge(x: i32) -> i32 {
    x + 1
    // x + 1; とするとそれは式から文に変わる
  }

  // 早期リターン
  // return を使って値を返すことができる
  // またRustでは以下のようなスタイルを推奨していない
  fn foo(x: i32) -> i32 {
    return x + 1;
  }

  // 発散する関数、すなわち値を返さない関数のための特別な構文がある
  fn diverges() -> ! {
    panic!("This function nerver returns!");
  }
  // 発散する関数の返り値は任意の型としても使える
  let x: i32 = diverges();
  let x: String = diverges();

  // 関数ポインタという関数を指示する変数束縛を作れる
  // 例えば以下の例はi32型を引数として受け取り、i32型を返す関数を指示する変数束縛
  fn plus_one(i: i32) -> i32 {
    i + 1
  }

  let f: fn(i32) -> i32 = plus_one;
  let six = f(5);
}
