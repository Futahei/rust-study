// 「借用」
// Rustの所有権システムの一つ。
// 所有権の例で以下のようなスクリプトがあった。
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
  (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
// これらはRust的なコードでない。なぜなら借用の利点を生かしていないからである。
// 上記の例を以下のように書き換える。
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
  // v1 と v2 について作業する

  // 答えを返す
  42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&v1, &v2);
// 引数として Vec<i32> を使う代わりに、参照、つまり &Vec<i32> を使う。
// &T 型は「参照」と呼ばれ、リソースを所有するのではなく、所有権を借用する。
// 参照は束縛と同様に変更不可なので、foo() の中で引数は変更できない。

// 参照にはもう一つ &mut T がある。ミュータブルな参照で、借用しているリソースを変更できる。
let mut x = 5;
{
  let y = &mut x;
  *y += 1;
}
println!("{}", x); // 6
// 当然、x も mut でなければならない。
// また、参照の内容にアクセスする時はアスタリスク( * )を y の前に追加する必要がある。

// &mut 参照と普通の参照はほとんど同じだが、それらがどのように相互作用するかは大きな違いがある。
// 前の例で、{ } を使ってスコープを用意したが、それがないとエラーになる。
// それは以下のルールが存在しているからである。

// まず、借用は全て所有者のスコープより長く存続してはならない。
// 次に、次の二種類の借用のどちらか一つを持つことはあるが、両方を同時に持つことはない。
// ・リソースに対する１つ以上の参照( &T )
// ・ただ１つのミュータブルな参照( &mut T )
// これらはデータ競合の定義と似ているが完全に同じではない。
// 書き込みを行わなければ参照は好きな数だけ使うことができる。
let mut x = 5;

let y = &mut x;    // -+ x の &mut 借用がここから始まる
                   //  |
*y += 1;           //  |
                   //  |
println!("{}", x); // -+ ここで x を借用しようとする
                   // -+ x の &mut 借用がここで終わる
// 先ほどの例は上記のようにスコープが衝突するためである。

// 借用によって回避できる問題がたくさんある。
// 以下にその例を示す。
// 「イテレータの無効」
// 繰り返しを行っているコレクションを変更することをできなくしている。
let mut v = vec![1, 2, 3];

for i in &v {
  // このスコープではv がイミュータブルに借用されている
  println!("{}", i);
  v.push(34); // error: cannot borrow `v` as mutable because it is also borrowed as immutable
}

// 「解放後の使用」
// 参照はそれらが指示するリソースよりも長く生存することはできない。
// 例えば以下の例では、無効な参照を行っている
let y: &i32;
{
  let x = 5;
  y = &x;
}

println!("{}", y); // error: `x` does not live long enough
// y は x が存在するスコープの中でだけ有効だということ。
// また宣言する順番によって生存する時間が変わる。
let y: &i32;
let x = 5;
y = &x;

println!("{}", y); // error: `x` does not live long enough
// 同じスコープにあるリソースはそれらの宣言された順番と逆に解放されていく
// つまり y が x より長く生存することになる。

