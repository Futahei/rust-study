// 「所有権」
// ゼロコスト抽象化：抽象化を機能させるためのコストをできるだけ小さくすること
// 解析は全てコンパイル時に行われる。つまり実行時にコストはかからない
// このシステムは学習曲線というコストをもつ。
// Rustユーザから「借用チェッカとの戦い」と呼ばれる、
// 良くぶつかる問題がある。

// 変数束縛とは束縛されているものの「所有権を持つ」ということ
// つまり束縛がスコープから外れる時、束縛されているリソースを解放するだろうことを意味する
fn foo() {
  let v = vec![1, 2, 3];
}
// v がスコープに入る時、新しいVec<T>が作られる
// ベクタが３つの要素を持つためヒープに割り当てられる
// v がスコープから抜ける時に、ヒープ割り当ても含めて完全に削除される

// 「ムーブセマンティクス」
// Rustは与えられたリソースに対する束縛が一つだけあることを保証している
// 例えば、もしベクタがあればそれを別の束縛に割り当てられる
let v = vec![1, 2, 3];
let v2 = v;
// しかし、もし後で v を使おうとするとエラーが出る
println!("v[0] is: {}", v[0]); // error: use of moved value: `v`
// もし所有権を受け取る関数を定義して、引数として何かを私た後で
// それを使おうとすると同じようにエラーが起きる
fn take(v: Vec<i32>) {
  // ここで何が起きようが関係ない
}
let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]); // error: use of moved value: `v`
// 所有権を何か別のものに転送する時、参照する物を「ムーブした」と言う

// なぜこのような仕様なのか、以下の例を詳しく見ていく
let v = vec![1, 2, 3];
let v2 = v;
// 最初の行でRustはベクタオブジェクト v と含まれるデータのためのメモリを割り当てる
// ヒープに保存されたデータ([1,2,3])を、スタックにそこへのポインタを保存する
// 二行目でvをv2にムーブする時、Rustはポインタのコピーを作る
// それはつまりヒープにある同じデータを指すポインタが二つあることを意味し、
// データ競合の観点からRustの安全性保証に違反する


// 「Copy型」
// 所有権が他の束縛に転送されたとき、元の束縛を使えないことは証明された
// この挙動を変更する Copy というトレイトがある
// 以下の例を考える
let v = 1;

let v2 = v;

println!("v is: {}", v);
// このとき v は i32 で Copy トレイトを実装している
// v を v2 に割り当てるとき、データの完全コピーが作られる
// このように全てのプリミティブ型は Copy トレイトを実装している

// しかしこのままでは複数の引数をとる関数を定義したとき、
// 所有権の返却は以下のように非常に面倒なことになる
fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {
  // v1 と v2 に関して作業する

  // 所有権と結果を返す
  (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);

// これを解決する手段が借用である

